import clava.autopar.Parallelize;
import lara.metrics.ExecutionTimeMetric;
import lara.cmake.CMaker;
import lara.Io;
import clava.Clava;
import clava.ClavaCode;
import clava.ClavaJoinPoints;



var $rawflags = [];
var $flags = [];
var $catflags = [];
var folderName = "flagRecommender";
var passName = folderName + ".json";
var root;
var main;
var mainFile;
var filename;
var results;
var firstFunction;
var files;

aspectdef Resolver

	var $loops = [];
	select loop end
	apply
		$loops.push($loop);
	end
	// print($loops.length);

	var executor = new ProcessExecutor();
	executor.setPrintToConsole(false);
	executor.execute("g++ --help=optimizers");

	parseFlags(executor.getConsoleOutput().split("\n"));
	categorizeFlags();
	// printCatFlags();

	call getMain();

	callNonio();

end


aspectdef getMain
	
	select program end
	apply
		root = $program;
	end

	files = [];
	var file, children;

	for (var i = 0; i < root.astNumChildren; i++)
	{
		file = root.astChild(i);
		children = file.astChildren;

		firstFunction = null;
		for (var i = 0; i < children.length; i++) // Remove local includes and find main
		{
			if (children[i].joinpointType === "include")
			{
				if (children[i].code.search(/\".*\"/) != -1)
				{
					children[i].detach();
				}
			}

			if (children[i].joinpointType === "function")
			{
				if (children[i].name === "main")
				{
					main = children[i];
					mainFile = file;
					print("Got the main!\n");
				}			
			}

		}
	}

	// Find first function of main file
	file = mainFile;
	children = file.astChildren;

	for (var i = 0; i < children.length; i++)
	{
		if (children[i].joinpointType === "function")
		{
			if (firstFunction === null)
			{
				firstFunction = children[i];
				break;
			}
		}
	}

	mergeFiles();

end


function mergeFiles()
{
	for (var i = 0; i < root.astNumChildren; i++) // Move includes to main file
	{
		var file = root.astChild(i);

		if (file.filename === main.filename)
			continue;

		var children = file.astChildren;

		for (var i = 0; i < children.length; i++)
		{
			if (children[i].joinpointType === "include")
			{
				children[i].detach();
				firstFunction.insertBefore(children[i].code);
			}
		}
	}

	for (var i = 0; i < root.astNumChildren; i++) // Move rest of file
	{
		var file = root.astChild(i);

		if (file.filename === main.filename)
			continue;

		var children = file.astChildren;

		for (var i = 0; i < children.length; i++)
		{
			children[i].detach();
			firstFunction = firstFunction.insertBefore(children[i].code);
		}

		file.detach();
	}
}

function callNonio()
{
	prepareNonioFiles();

	var executor = new ProcessExecutor();
	executor.setPrintToConsole(false);
	executor.setWorkingDir("../nonio/examples/" + folderName + "/");
	executor.setPrintToConsole(true);
	executor.execute("nonio arguments.properties -b 2");

	getNonioResults();

	compileWithBestResult();
}

function prepareNonioFiles()
{
	Io.deleteFolder("../nonio/examples/"  + folderName);
	Io.mkdir("../nonio/examples/" + folderName);

	createArgumentsFile();

	createNonioCodeFiles();

	createPassFile();
}

function createArgumentsFile(nsteps, algo)
{
	if (nsteps == undefined)
		nsteps = 50;

	if (algo == undefined)
		algo = "sa";


	var content = "";
	
	content += "\nsourceFile = '" + folderName + ".c'\n";
	content += "compiler = 'gcc'\n";
	content += "nsteps = " + nsteps + "\n";
	content += "language = 'c'\n";
	content += "target = 'host-intel'\n";
	content += "algo = " + "'" + algo + "'\n";
	content += "seqlen = 32\n";
	content += "nexec = 1\n";
	content += "minimumExecForReporting = 30\n";
	content += "passes = ''\n";
	content += "percent = 2\n";
	content += "append = ''\n";
	content += "metrics = ['performance']\n";
	content += "alreadyInstrumented = false\n";
	content += "storeResults = true";

	Io.writeFile("../nonio/examples/" + folderName + "/arguments.properties", content);
}

function createNonioCodeFiles()
{
	var file = main.parent;

	main.name = "originalMain";
	var newMain = main.clone("main");
	var children = newMain.astChild(0).astChildren;

	for (var i = 0; i < children.length-1; i++)
	{
		children[i].detach();
	}
	
	var lastNode = children[children.length-1];
	lastNode = lastNode.replaceWith("#pragma monitor start");
	lastNode = lastNode.insertAfter("int ret = originalMain();");
	lastNode = lastNode.insertAfter("#pragma monitor stop");
	lastNode = lastNode.insertAfter("if (ret == 0) return 10;");
	lastNode = lastNode.insertAfter("else return 1;");

	Io.writeFile("../nonio/examples/" + folderName + "/" + folderName + "_main.c", "int originalMain();\n\n" + newMain.code);
	Io.writeFile("../nonio/examples/" + folderName + "/" + folderName + "_verify.c", "int originalMain();\n\n" + newMain.code);

	newMain.detach();

	Io.writeFile("../nonio/examples/" + folderName + "/" + folderName + ".c", file.code);
}

function createPassFile()
{
	Io.writeJson("../nonio/bundles/compilers/gcc/" + passName, $rawflags);

	var platformFile = Io.readJson("../nonio/bundles/platforms/host-intel/target_config.json");
	platformFile['compiler']['gcc']['passes'] = passName;
	Io.deleteFile("../nonio/bundles/platforms/host-intel/target_config.json");
	Io.writeJson("../nonio/bundles/platforms/host-intel/target_config.json", platformFile);
}

function getNonioResults()
{
	var nonioResults = Io.readJson("../nonio/examples/" + folderName + "/dse_results.json");

	if (nonioResults.length == 1)
		nonioResults = nonioResults[0];

	var ignore = true;
	results = [];
	var flagCombination;
	var flagTime;
	for (var foo in nonioResults) // Pass from json to array
	{
		for (var bar in nonioResults[foo])
		{
			if (ignore)
			{
				for (var foobar in nonioResults[foo][bar])
				{
					if (nonioResults[foo][bar][foobar] == "-O1")
						ignore = false;
				}
			}
			else
			{
				var errorMessage = nonioResults[foo][bar]["errorMessage"];

				if (errorMessage == undefined)
				{
					flagCombination = nonioResults[foo][bar]["compilerSequence"];
					
					flagTime = nonioResults[foo][bar]["values"];
					
					results.push([flagCombination, flagTime]);
				}
			}
		}
			
	}


	results = results.sort(function(a, b)
	{
		if (a[1]-b[1] == 0)
			return a[0].length - b[0].length;
		else
			return a[1]-b[1];
	});

	print("----------------------- Top 10 results: -----------------------\n");
	for (var i = 0; i < results.length && i < 10; i++)
	{
		print("flags: '" + results[i][0] + "' , time: " + results[i][1] + "\n");
	}
}

function compileWithBestResult()
{
	var args = results[0][0][0].split(" ");
	main.name = "main";

	var binaryName;

	if (mainFile.filename.indexOf('.') != -1)
		binaryName = mainFile.filename.substring(0, mainFile.filename.indexOf('.'));
	else
		binaryName = mainFile.filename;

	var cmaker = new CMaker(binaryName, false);
	cmaker.addCurrentAst();

	for (var i = 0; i < args.length; i++)
	{
		cmaker.addCFlags(args[i]);
	}

	var binary =  cmaker.build("temp", ".");
	print("Compiling with best combination(" + results[0][0][0] + ") to " + binary);
}


function addFlag(flagName, flagDescription)
{
	$rawflags.push(flagName);
	$flags.push([flagName, flagDescription]);
}

function removeFlag(i)
{
	$flags.splice(i);
	$rawflags.splice(i);
}

function parseFlags($lines)
{
	for (var i = 1; i < $lines.length; i++)
	{
		var line = $lines[i];

		if (line.search("-") == -1 && $flags.length != 0)
		{
			$flags[$flags.length-1][1] = $flags[$flags.length-1][1].concat(line['replace'](/\s\s+/g, " ")['replace'](/\r/g, "")['replace'](".", ""));
			continue;
		}

		var pos = line.search("-f");

		if (pos == -1)
			continue;

		var j, flag = false;
		for (j = pos; j < line.length; j++)
		{
			var currChar = line.charAt(j);

			if (currChar == ' ')
			{
				flag = true;
				continue;
			}

			else if (flag)
				break;
		}

		var flagName = line.substring(pos, j-2).trim();

		if (flagName.search("=") != -1)
			continue;

		var description = line.substring(j)['replace']("\r", "")['replace'](".", "");

		addFlag(flagName, description);
	}
}


function categorizeFlags()
{
	$catflags["generic"] = [];
	$catflags["recursive"] = [];
	$catflags["loop"] = [];
	$catflags["float"] = [];
	$catflags["string"] = [];
	$catflags["math"] = [];
	// "IRA"
	// "schedul"
	// "Common subexpression elimination"

	for (var i = 0; i < $flags.length; i++)
	{
		if ($flags[i][0].search("loop") != -1 || $flags[i][1].search("loop") != -1)
		{
			$catflags["loop"].push($flags[i]);
		}
		else if ($flags[i][0].search("math") != -1 || $flags[i][1].search("math") != -1)
		{
			$catflags["math"].push($flags[i]);
		}
		else if ($flags[i][0].search("recurs") != -1 || $flags[i][1].search("recurs") != -1)
		{
			$catflags["recursive"].push($flags[i]);
		}
		else if ($flags[i][0].search("string") != -1 || $flags[i][1].search("string") != -1)
		{
			$catflags["string"].push($flags[i]);
		}
		else if ($flags[i][0].search("float") != -1 || $flags[i][1].search("float") != -1)
		{
			$catflags["float"].push($flags[i]);
		}
		else
		{
			$catflags["generic"].push($flags[i]);
		}
	}
}


function printCatFlags()
{
	for (var catIndex in $catflags)
	{
		var category = $catflags[catIndex];
		print(catIndex + "(" + category.length + ")" + ":" + "\n");

		for (var i = 0; i < category.length; i++)
		{
			print(category[i][0] + " : " + category[i][1] + "\n");
		}
		print("\n");
	}
}